#!/bin/bash
#
# Copyright (C) - 2013 David Goulet <dgoulet@efficios.com>
#
# This library is free software; you can redistribute it and/or modify it under
# the terms of the GNU Lesser General Public License as published by the Free
# Software Foundation; version 2.1 of the License.  details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this library; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301 USA

CURDIR=$(dirname $0)/
TESTDIR=$CURDIR/..
LAUNCH_APP="launch_ust_app"
SESSION_NAME="stress"
EVENT_NAME="tp:tptest"
LOG_FILE_SESSIOND="sessiond.log"
LOG_FILE_ERROR_SESSIOND="${LOG_FILE_SESSIOND}.error"
LOG_FILE_RELAYD="relayd.log"
LOG_FILE_ERROR_RELAYD="${LOG_FILE_RELAYD}.error"
CHANNEL_NAME="channel0"
NR_APP=5
NR_SESSION=5
NR_LOOP=1000
COREDUMP_FILE=$(cat /proc/sys/kernel/core_pattern)
NUM_TESTS=16
APPS_PID=

TEST_DESC="Stress test - $NR_SESSION sessions per UID streaming with $NR_APP apps"

source $TESTDIR/utils/utils.sh

# MUST set TESTDIR before calling those functions

if [[ ! -z "$REMOTE_RELAYD_TEST" ]]; then
	override_base_command_ssh $REMOTE_RELAYD_HOST $REMOTE_RELAYD_USER $REMOTE_RELAYD_ID_FILE
	# Enable remote core dump
	$BASE_COMMAND "ulimit -c unlimited"
fi

TRACE_PATH=$($BASE_COMMAND "mktemp -d")

function check_sessiond()
{
	if [ -z "$(pgrep --full lt-lttng-sessiond)" ]; then
		local str_date=$(date +%H%M%S-%d%m%Y)

		diag "!!!The session daemon died unexpectedly!!!"
		mv $LOG_FILE_SESSIOND $LOG_FILE_SESSIOND-$str_date
		mv $LOG_FILE_ERROR_SESSIOND $LOG_FILE_ERROR_SESSIOND-$str_date
		if [ -e $COREDUMP_FILE ]; then
			mv $COREDUMP_FILE $COREDUMP_FILE-$str_date
		fi
		exit 1
	fi
}

function check_relayd()
{
	local relayd_bin_name="lt-$RELAYD_BIN"

	if [ ! -z "$REMOTE_RELAYD_TEST" ]; then
		if [[ "$BASE_COMMAND" == "$LOCAL_COMMAND" ]]; then
			fail "Kill remote relay daemon: base command not overridden"
			return 1
		fi
		# Override default value of regex name
		relayd_bin_name="$REMOTE_RELAYD_BIN"
	fi

	if [ -z "$($BASE_COMMAND "pgrep --full $relayd_bin_name[^\[]")" ]; then
		local str_date=$(date +%H%M%S-%d%m%Y)

		diag "!!!The relay daemon died unexpectedly!!!"
		$BASE_COMMAND "mv $LOG_FILE_RELAYD $LOG_FILE_RELAYD-$str_date"
		$BASE_COMMAND "mv $LOG_FILE_ERROR_RELAYD $LOG_FILE_ERROR_RELAYD-$str_date"
		exit 1
	fi
}

function test_stress()
{
	local host="localhost"

	if [[ ! -z "$REMOTE_RELAYD_TEST" ]]; then
		host=$REMOTE_RELAYD_HOST
	fi

	for b in $(seq 1 $NR_LOOP); do
		for a in $(seq 1 $NR_SESSION); do
			create_lttng_session_ok $SESSION_NAME-$a "" "-U net://$host"
			check_sessiond
			check_relayd
			enable_ust_lttng_channel_ok $SESSION_NAME-$a $CHANNEL_NAME "--buffers-uid"
			check_sessiond
			check_relayd
			enable_ust_lttng_event_ok $SESSION_NAME-$a $EVENT_NAME $CHANNEL_NAME
			check_sessiond
			check_relayd
			start_lttng_tracing_ok $SESSION_NAME-$a
			check_sessiond
			check_relayd
		done

		for a in $(seq 1 $NR_SESSION); do
			stop_lttng_tracing_ok $SESSION_NAME-$a
			check_sessiond
			check_relayd
			destroy_lttng_session_ok $SESSION_NAME-$a
			check_sessiond
			check_relayd
		done
	done

	return 0
}

function cleanup()
{
	diag "Cleaning up!"
	for p in ${APPS_PID}; do
		kill -s SIGKILL ${p}
		wait ${p} 2>/dev/null
	done
	APPS_PID=
	stop_lttng_sessiond
	stop_lttng_relayd_remote_support
}

function sighandler()
{
	cleanup
	rm $LOG_FILE_SESSIOND
	rm $LOG_FILE_ERROR_SESSIOND

	$BASE_COMMAND "rm $LOG_FILE_RELAYD"
	$BASE_COMMAND "rm $LOG_FILE_ERROR_RELAYD"

	exit 1
}

trap sighandler SIGINT
trap sighandler SIGTERM

# Make sure we collect a coredump if possible.
ulimit -c unlimited

# MUST set TESTDIR before calling those functions
plan_tests $NUM_TESTS

print_test_banner "$TEST_DESC"

OUTPUT_DEST="$LOG_FILE_RELAYD"
ERROR_OUTPUT_DEST="$LOG_FILE_ERROR_RELAYD"
start_lttng_relayd_remote_support "-o $TRACE_PATH"

OUTPUT_DEST="$LOG_FILE_SESSIOND"
ERROR_OUTPUT_DEST="$LOG_FILE_ERROR_SESSIOND"
start_lttng_sessiond

OUTPUT_DEST="/dev/null"
ERROR_OUTPUT_DEST="/dev/null"

diag "Starting applications launcher"

# Start NR_APP applications script that will spawn apps non stop.
./$TESTDIR/stress/$LAUNCH_APP $NR_APP &
APPS_PID="${APPS_PID} ${!}"

test_stress
out=$?
if [ $out -ne 0 ]; then
	cleanup
	exit $out
fi

cleanup
$BASE_COMMAND "rm -rf $TRACE_PATH"
$BASE_COMMAND rm $LOG_FILE_RELAYD
rm $LOG_FILE_SESSIOND
exit 0
